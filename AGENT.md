# agent.md — HW: Conway’s Game of Life в RARS (графический дисплей) — цель 10/10

## Цель
Реализовать в симуляторе **RARS** программу на **RISC-V assembly**, которая отображает состояние клеточного автомата «Игра Жизнь» Джона Конвея на **графическом дисплее** RARS: каждой клетке соответствует **1 пиксель**. Поле фиксированного размера в диапазоне **[16x16 .. 32x32]**.  

Требования на 10/10:
1) Ввод начального состояния с **консоли** RARS.  
2) Добавить ввод начального состояния из **файла по имени** (минимум 2 примера файлов).  
3) После ввода — запуск симуляции и визуализация на дисплее.  
4) Завершение по **вымиранию** (нет живых клеток) или вручную (пользователь прерывает).  
5) Параметры поля (прямоугольное/квадратное/тороидальное) выбрать и реализовать.

## Выбор параметров (фиксировать в реализации)
- Размер поля: **32x32** (макс. разрешённый, удобен для адресации).
- Тип поля: **тороидальное** (с заворачиванием по краям), чтобы «не умирало об стенки» и выглядело эффектнее.
- Отображение:
  - Живая клетка: белый пиксель `0x00FFFFFF`
  - Мёртвая клетка: чёрный пиксель `0x00000000`
- Буферизация:
  - Два массива `curr[1024]`, `next[1024]` (по 32*32 байт или слов — выбрать удобно по коду).
  - После шага делать swap указателей.

## Пользовательский интерфейс (консоль)
После запуска программа должна вывести меню и поддерживать 2 режима инициализации:

### Режим 1: Ввод с консоли
Запросить:
1) Количество живых клеток `K`
2) Далее `K` строк пар координат: `x y` (0 <= x,y < 32)
Все координаты вне диапазона — игнорировать или выводить предупреждение и просить повторить.

### Режим 2: Ввод из файла
Запросить строкой имя файла (например `glider.txt`), затем загрузить.

Формат файла (простой, без лишней парсер-сложности):
- Первая строка: `K`
- Далее `K` строк: `x y`
Пример:
5
1 0
2 1
0 2
1 2
2 2

  
Обязательно приложить в репозитории минимум **2 файла**:
- `glider.txt` (глайдер)
- `blinker.txt` (осциллятор) или `lwss.txt` (кораблик)

## Симуляция
- Отрисовать стартовое состояние на дисплее.
- Далее выполнять итерации:
  1) Посчитать число живых соседей для каждой клетки (8 соседей, тор).
  2) Применить правила:
     - живая клетка выживает при 2 или 3 соседях
     - мёртвая рождается при 3 соседях
     - иначе становится/остаётся мёртвой
  3) Перерисовать дисплей (оптимально — рисовать только изменившиеся клетки, но допускается полная перерисовка 32x32).
  4) Небольшая задержка (sleep через системный вызов RARS или через простой busy-loop, предпочтительнее системный sleep).
  5) Проверка вымирания: если суммарно живых клеток 0 — вывести сообщение и завершить.

Прерывание пользователем допускается (stop в RARS).

## Графический дисплей в RARS — требования по реализации
- Использовать Memory-Mapped I/O RARS для Bitmap Display.
- Предположить стандартную настройку Bitmap Display:
  - Base address: `0x10008000` (типичный вариант в RARS)
  - Width/Height: 32x32 (1 пиксель = 1 слово/пиксель)
- В README указать, как настроить Bitmap Display в RARS (Tools -> Bitmap Display):
  - Unit Width = 1
  - Unit Height = 1
  - Display Width = 32
  - Display Height = 32
  - Base Address = 0x10008000
(Если в вашей версии RARS base-address отличается, вынести в константу и явно указать в README.)

Адресация пикселя (x,y):
- index = y*32 + x
- addr = BASE + index*4
- store word color в addr

## Архитектура кода (обязательно)
Сделать код структурированным, с подпрограммами (calls) и понятными именами меток:

Обязательные функции:
- `main`
- `print_menu_and_read_mode`
- `clear_grid(ptr)`
- `set_cell_alive(ptr, x, y)`
- `draw_grid(ptr)`
- `step_life(curr_ptr, next_ptr) -> returns alive_count_next`
- `count_neighbors_torus(curr_ptr, x, y) -> a0`
- `read_int` (если удобно) / использовать ecall чтения int
- `read_string` (для имени файла)
- `load_from_file(filename, curr_ptr) -> returns K_loaded or error`
- `delay`

Требования к стилю:
- Комментарии к каждому блоку: что делает, какие регистры/аргументы использует, что возвращает.
- Явно сохранять/восстанавливать `ra` и callee-saved регистры по ABI.
- Не использовать “магические числа” — все ключевые константы через `.equ`/`.set`.

## Обработка ошибок (обязательно)
- Если файл не открылся — вывести понятное сообщение и предложить ввести имя заново или переключиться на ввод с консоли.
- Если `K` слишком большой — ограничить максимумом 1024.
- Если координаты вне диапазона — игнорировать/сообщать.

## Артефакты проекта (что должно быть в репозитории)
- `life.s` (или `main.s`) — основной код.
- `glider.txt`, `blinker.txt` — примеры входных файлов.
- `README.md` — инструкция запуска (как настроить Bitmap Display + как вводить).
- (Опционально) `screenshots/` с 1–2 скринами работы.

## Тест-план (минимум)
1) Console input: K=5 glider — проверить, что движется.
2) File input: glider.txt — то же.
3) File input: blinker.txt — осциллирует.
4) Empty (K=0) — сразу завершение по вымиранию.

## Определение “готово”
Задача считается выполненной на 10/10, если:
- Поле 32x32 (или иное в 16..32), 1 клетка = 1 пиксель.
- Есть ввод с консоли и ввод из файла.
- Есть минимум 2 файла-примера.
- Игра запускается и визуализируется.
- Завершение корректно определяется по вымиранию.
- README объясняет компиляцию/запуск в RARS и настройку Bitmap Display.

## Важно
- Никаких заглушек и “TODO”.
- Писать код так, чтобы он запускался в чистом RARS без внешних зависимостей.
- В README включить точные шаги (Tools -> Bitmap Display -> параметры) и команды запуска.
